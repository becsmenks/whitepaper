TRUE ~ "Waypoint"),
`Location Type` = factor(
`Location Type`,
levels = c("Origin",
"Waypoint",
"Charging Stop",
"Destination"))) %>%
rename(Distance = dist) %>%
ggplot() +
aes(x = x, y = y,
label = Distance,
colour = `Location Type`,
shape = `Location Type`) +
geom_point() +
xlab("") +
ylab("") +
theme_bw() +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
scale_shape_manual(values = c("Origin" = "15",
"Waypoint" = "16",
"Charging Stop" = "3",
"Destination" = "15")) +
scale_color_manual(values = c("Origin" = "black",
"Waypoint" = "blue",
"Charging Stop" = "red",
"Destination" = "#3f840b")),
tooltip = c("label")
)
})
# Plot the full simulation
output$sim_plot <- renderPlotly({
group_var_name <- input$select_group_var
ggplotly(
sim_results %>%
mutate(Distance = paste(network_distance, "miles"),
Range = paste(battery_size, "miles"),
`Battery Cost` = paste0("$", battery_unit_cost, "/mile"),
`Charger Cost` = paste0("$", charger_unit_cost/1000, "k/charger"),
`Vehicles per Charger` = paste(veh2chr_ratio),
`Chargers per Site` = paste(chr2loc_ratio)) %>%
rename(c('group_var' = group_var_name)) %>%
group_by(group_var) %>%
summarise_at(c('battery_total_cost', 'charger_total_cost'),
input$select_group_op) %>%
ungroup() %>%
mutate(battery_total_cost = battery_total_cost / 1000000,
charger_total_cost = charger_total_cost / 1000000) %>%
ggplot() +
aes(x = battery_total_cost,
y = charger_total_cost,
color = group_var) +
geom_point() +
geom_point(data =
tibble(
Distance = paste(input$network_distance, "miles"),
Range = paste(input$battery_size, "miles"),
`Battery Cost` = paste0("$", input$battery_cost, "/mile"),
`Charger Cost` = paste0("$", input$charger_cost/1000, "k/charger"),
`Vehicles per Charger` = paste(input$veh2chr_ratio),
`Chargers per Site` = paste(input$chr2loc_ratio),
battery_total_cost = total_battery_cost() / 1000000,
charger_total_cost = total_charger_cost() / 1000000
) %>%
rename(c('group_var' = group_var_name)),
shape = 18,
size = 5) +
geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
xlab(paste(input$select_group_op, "Average Total Battery Cost (Millions)")) +
ylab(paste(input$select_group_op, "Average Total Charger Cost (Millions)")) +
theme_bw() +
scale_x_continuous(labels = scales::dollar_format()) +
scale_y_continuous(labels = scales::dollar_format()) +
guides(color = guide_legend(title=group_var_name)) +
expand_limits(x = 0, y = 0),
tooltip = c("Distance")
)
})
# Calculate total battery cost
output$battery_cost_kpi <- renderInfoBox({
# Create the info box
infoBox(
HTML(paste0('<font color="#3f840b" size =6><b>$',
format(round(total_battery_cost() / 1000000),
big.mark = ",",
scientific = FALSE),
'</b></font>')),
icon = icon("battery-full")
)
})
# Calculate total charger cost
output$charger_cost_kpi <- renderInfoBox({
# Create the info box
infoBox(
HTML(paste0('<font color="#3f840b" size =6><b>$',
format(round(total_charger_cost() / 1000000),
big.mark = ",",
scientific = FALSE),
'</b></font>')),
icon = icon("charging-station")
)
})
}
shinyApp(ui, server)
library(stringr)
# Define server logic required to calculate costs
server <- function(input, output) {
# Create the distance grid
grid <- reactive({
make_grid(input$network_distance,
50,
"diamond")
})
# Identify the required locations of chargers
charger_locations <- reactive({
locate_chargers(input$network_distance,
input$battery_size)
})
# Count the number of locations
num_locations <- reactive({
count_num_locations(grid(), charger_locations())
})
# Count the number of vehicles
num_vehicles <- reactive({
count_num_vehicles(num_locations(), input$chr2loc_ratio, input$veh2chr_ratio)
})
# Get the total charger installation cost to get to destination on outer edge
# of the grid
total_charger_cost <- reactive({
cost1 = calc_total_charger_cost(num_locations(),
input$chr2loc_ratio,
input$charger_cost)
battery_cost_range = max(input$network_distance - 100, 0)
charger_cost_range = max(min(input$battery_size, input$network_distance) - 100, 0)
charger_cost_frac_of_battery_cost = if_else(battery_cost_range == 0, 0,
charger_cost_range / battery_cost_range)
cost2 = total_battery_cost() * charger_cost_frac_of_battery_cost
cost1 + cost2
})
# Get the total incremental battery cost to get to destination on outer edge
# of the grid
total_battery_cost <- reactive({
calc_total_battery_cost(num_vehicles(),
input$battery_cost,
input$network_distance)
})
# Plot the network
output$grid_plot <- renderPlotly({
# Visualize the grid
ggplotly(
grid() %>%
mutate(
`Location Type` = case_when(
dist == input$network_distance ~ "Destination",
dist == 0 ~ "Origin",
dist %in% charger_locations() ~ "Charging Stop",
TRUE ~ "Waypoint"),
`Location Type` = factor(
`Location Type`,
levels = c("Origin",
"Waypoint",
"Charging Stop",
"Destination"))) %>%
rename(Distance = dist) %>%
ggplot() +
aes(x = x, y = y,
label = Distance,
colour = `Location Type`,
shape = `Location Type`) +
geom_point() +
xlab("") +
ylab("") +
theme_bw() +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
scale_shape_manual(values = c("Origin" = "15",
"Waypoint" = "16",
"Charging Stop" = "3",
"Destination" = "15")) +
scale_color_manual(values = c("Origin" = "black",
"Waypoint" = "blue",
"Charging Stop" = "red",
"Destination" = "#3f840b")),
tooltip = c("label")
)
})
# Plot the full simulation
output$sim_plot <- renderPlotly({
group_var_name <- input$select_group_var
ggplotly(
sim_results %>%
mutate(Distance = paste(network_distance, "miles"),
Range = paste(battery_size, "miles"),
`Battery Cost` = paste0("$", battery_unit_cost, "/mile"),
`Charger Cost` = paste0("$", charger_unit_cost/1000, "k/charger"),
`Vehicles per Charger` = paste(veh2chr_ratio),
`Chargers per Site` = paste(chr2loc_ratio)) %>%
rename(c('group_var' = group_var_name)) %>%
group_by(group_var) %>%
summarise_at(c('battery_total_cost', 'charger_total_cost'),
input$select_group_op) %>%
ungroup() %>%
mutate(battery_total_cost = battery_total_cost / 1000000,
charger_total_cost = charger_total_cost / 1000000) %>%
ggplot() +
aes(x = battery_total_cost,
y = charger_total_cost,
color = group_var) +
geom_point() +
geom_point(data =
tibble(
Distance = paste(input$network_distance, "miles"),
Range = paste(input$battery_size, "miles"),
`Battery Cost` = paste0("$", input$battery_cost, "/mile"),
`Charger Cost` = paste0("$", input$charger_cost/1000, "k/charger"),
`Vehicles per Charger` = paste(input$veh2chr_ratio),
`Chargers per Site` = paste(input$chr2loc_ratio),
battery_total_cost = total_battery_cost() / 1000000,
charger_total_cost = total_charger_cost() / 1000000
) %>%
rename(c('group_var' = group_var_name)),
shape = 18,
size = 5) +
geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
xlab(paste(str_to_title(input$select_group_op),
"Average Total Battery Cost (Millions)")) +
ylab(paste(str_to_title(input$select_group_op),
"Average Total Charger Cost (Millions)")) +
theme_bw() +
scale_x_continuous(labels = scales::dollar_format()) +
scale_y_continuous(labels = scales::dollar_format()) +
guides(color = guide_legend(title=group_var_name)) +
expand_limits(x = 0, y = 0),
tooltip = c("Distance")
)
})
# Calculate total battery cost
output$battery_cost_kpi <- renderInfoBox({
# Create the info box
infoBox(
HTML(paste0('<font color="#3f840b" size =6><b>$',
format(round(total_battery_cost() / 1000000),
big.mark = ",",
scientific = FALSE),
'</b></font>')),
icon = icon("battery-full")
)
})
# Calculate total charger cost
output$charger_cost_kpi <- renderInfoBox({
# Create the info box
infoBox(
HTML(paste0('<font color="#3f840b" size =6><b>$',
format(round(total_charger_cost() / 1000000),
big.mark = ",",
scientific = FALSE),
'</b></font>')),
icon = icon("charging-station")
)
})
}
shinyApp(ui, server)
# Define server logic required to calculate costs
server <- function(input, output) {
# Create the distance grid
grid <- reactive({
make_grid(input$network_distance,
50,
"diamond")
})
# Identify the required locations of chargers
charger_locations <- reactive({
locate_chargers(input$network_distance,
input$battery_size)
})
# Count the number of locations
num_locations <- reactive({
count_num_locations(grid(), charger_locations())
})
# Count the number of vehicles
num_vehicles <- reactive({
count_num_vehicles(num_locations(), input$chr2loc_ratio, input$veh2chr_ratio)
})
# Get the total charger installation cost to get to destination on outer edge
# of the grid
total_charger_cost <- reactive({
cost1 = calc_total_charger_cost(num_locations(),
input$chr2loc_ratio,
input$charger_cost)
battery_cost_range = max(input$network_distance - 100, 0)
charger_cost_range = max(min(input$battery_size, input$network_distance) - 100, 0)
charger_cost_frac_of_battery_cost = if_else(battery_cost_range == 0, 0,
charger_cost_range / battery_cost_range)
cost2 = total_battery_cost() * charger_cost_frac_of_battery_cost
cost1 + cost2
})
# Get the total incremental battery cost to get to destination on outer edge
# of the grid
total_battery_cost <- reactive({
calc_total_battery_cost(num_vehicles(),
input$battery_cost,
input$network_distance)
})
# Plot the network
output$grid_plot <- renderPlotly({
# Visualize the grid
ggplotly(
grid() %>%
mutate(
`Location Type` = case_when(
dist == input$network_distance ~ "Destination",
dist == 0 ~ "Origin",
dist %in% charger_locations() ~ "Charging Stop",
TRUE ~ "Waypoint"),
`Location Type` = factor(
`Location Type`,
levels = c("Origin",
"Waypoint",
"Charging Stop",
"Destination"))) %>%
rename(Distance = dist) %>%
ggplot() +
aes(x = x, y = y,
label = Distance,
colour = `Location Type`,
shape = `Location Type`) +
geom_point() +
xlab("") +
ylab("") +
theme_bw() +
theme(axis.text = element_blank(),
axis.ticks = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
scale_shape_manual(values = c("Origin" = "15",
"Waypoint" = "16",
"Charging Stop" = "3",
"Destination" = "15")) +
scale_color_manual(values = c("Origin" = "black",
"Waypoint" = "blue",
"Charging Stop" = "red",
"Destination" = "#3f840b")),
tooltip = c("label")
)
})
# Plot the full simulation
output$sim_plot <- renderPlotly({
group_var_name <- input$select_group_var
ggplotly(
sim_results %>%
mutate(Distance = paste(network_distance, "miles"),
Range = paste(battery_size, "miles"),
`Battery Cost` = paste0("$", battery_unit_cost, "/mile"),
`Charger Cost` = paste0("$", charger_unit_cost/1000, "k/charger"),
`Vehicles per Charger` = paste(veh2chr_ratio),
`Chargers per Site` = paste(chr2loc_ratio)) %>%
rename(c('group_var' = group_var_name)) %>%
group_by(group_var) %>%
summarise_at(c('battery_total_cost', 'charger_total_cost'),
input$select_group_op) %>%
ungroup() %>%
mutate(battery_total_cost = battery_total_cost / 1000000,
charger_total_cost = charger_total_cost / 1000000) %>%
ggplot() +
aes(x = battery_total_cost,
y = charger_total_cost,
color = group_var) +
geom_point() +
geom_point(data =
tibble(
Distance = paste(input$network_distance, "miles"),
Range = paste(input$battery_size, "miles"),
`Battery Cost` = paste0("$", input$battery_cost, "/mile"),
`Charger Cost` = paste0("$", input$charger_cost/1000, "k/charger"),
`Vehicles per Charger` = paste(input$veh2chr_ratio),
`Chargers per Site` = paste(input$chr2loc_ratio),
battery_total_cost = total_battery_cost() / 1000000,
charger_total_cost = total_charger_cost() / 1000000
) %>%
rename(c('group_var' = group_var_name)),
shape = 18,
size = 5) +
geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
xlab(paste(str_to_title(input$select_group_op),
"Total Battery Cost (Millions)")) +
ylab(paste(str_to_title(input$select_group_op),
"Total Charger Cost (Millions)")) +
theme_bw() +
scale_x_continuous(labels = scales::dollar_format()) +
scale_y_continuous(labels = scales::dollar_format()) +
guides(color = guide_legend(title=group_var_name)) +
expand_limits(x = 0, y = 0),
tooltip = c("Distance")
)
})
# Calculate total battery cost
output$battery_cost_kpi <- renderInfoBox({
# Create the info box
infoBox(
HTML(paste0('<font color="#3f840b" size =6><b>$',
format(round(total_battery_cost() / 1000000),
big.mark = ",",
scientific = FALSE),
'</b></font>')),
icon = icon("battery-full")
)
})
# Calculate total charger cost
output$charger_cost_kpi <- renderInfoBox({
# Create the info box
infoBox(
HTML(paste0('<font color="#3f840b" size =6><b>$',
format(round(total_charger_cost() / 1000000),
big.mark = ",",
scientific = FALSE),
'</b></font>')),
icon = icon("charging-station")
)
})
}
shinyApp(ui, server)
# HEADER ------------------------------------------------------------------
# Project: Charging Optimization Whitepaper
# Date: May 2021
# Description: This script pre-runs the simulations for the widget.
# Sections: A - Setup Code
#           B - Run Simulations
#           C - Summarize Results
#           D - Save Data
# A - Setup Code ----------------------------------------------------------
source('init.R')
# B - Run Simulation ------------------------------------------------------
sim_results_battery <- NULL
sim_results_charger <- NULL
# Loop through network distances
for (d in seq(from = values$network_distance$min,
to = values$network_distance$max,
by = values$network_distance$by)) {
print(paste("Simulating network distance:", d, "miles"))
grid <- make_grid(distance = d,
step_size = 50,
shape = "diamond")
# Loop through battery sizes
for (s in seq(from = values$battery_size$min,
to = values$battery_size$max,
by = values$battery_size$by)) {
locations <- locate_chargers(d, s)
num_locations <- count_num_locations(grid, locations)
# Loop through chargers per site
for (r1 in seq(from = values$chr2loc_ratio$min,
to = values$chr2loc_ratio$max,
by = values$chr2loc_ratio$by)) {
# Loop through vehicles per charger
for (r2 in seq(from = values$veh2chr_ratio$min,
to = values$veh2chr_ratio$max,
by = values$veh2chr_ratio$by)) {
num_vehicles <- count_num_vehicles(num_locations, r1, r2)
# Loop through battery costs
for (bc in seq(from = values$battery_cost$min,
to = values$battery_cost$max,
by = values$battery_cost$by)) {
total_battery_cost <- calc_total_battery_cost(num_vehicles, bc, d)
# Make results dataframe
sim_results_battery <- tibble(
network_distance = d,
battery_size = s,
veh2chr_ratio = r2,
chr2loc_ratio = r1,
battery_unit_cost = bc,
battery_total_cost = total_battery_cost
) %>%
bind_rows(sim_results_battery)
}
# Loop through charger costs
for (cc in seq(from = values$charger_cost$min,
to = values$charger_cost$max,
by = values$charger_cost$by)) {
total_charger_cost <- calc_total_charger_cost(num_locations, r1, cc)
# Make results dataframe
sim_results_charger <- tibble(
network_distance = d,
battery_size = s,
chr2loc_ratio = r1,
charger_unit_cost = cc,
charger_total_cost = total_charger_cost
) %>%
bind_rows(sim_results_charger)
}
}
}
}
}
# C - Summarize Results ---------------------------------------------------
sim_results <- sim_results_battery %>%
left_join(sim_results_charger, by = c("network_distance",
"battery_size",
"chr2loc_ratio")) %>%
rename(charger_total_cost_low = charger_total_cost) %>%
mutate(battery_cost_range = pmax(network_distance - 100, 0),
charger_cost_range = pmax(pmin(battery_size, network_distance) - 100, 0),
charger_cost_frac_of_battery_cost = if_else(
battery_cost_range == 0, 0, charger_cost_range / battery_cost_range),
charger_total_cost_adder = charger_cost_frac_of_battery_cost * battery_total_cost,
charger_total_cost = charger_total_cost_low + charger_total_cost_adder)
source('init.R')
getwd()
setwd("/Users/bikeymuss/git/whitepaper")
getwd()
